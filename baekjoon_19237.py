# 어른 상어
'''
문제
상어에는 1 이상 M 이하의 자연수 번호가 붙어 있고, 모든 번호는 서로 다르다.
상어들은 영역을 사수하기 위해 다른 상어들을 쫓아내려고 하는데, 1의 번호를 가진 어른 상어는 가장 강력해서 나머지 모두를 쫓아낼 수 있다.

N×N 크기의 격자 중 M개의 칸에 상어가 한 마리씩 들어 있다.
맨 처음에는 모든 상어가 자신의 위치에 자신의 냄새를 뿌린다.
그 후 1초마다 모든 상어가 동시에 상하좌우로 인접한 칸 중 하나로 이동하고, 자신의 냄새를 그 칸에 뿌린다.
냄새는 상어가 k번 이동하고 나면 사라진다.

각 상어가 이동 방향을 결정할 때는,
1) 먼저 인접한 칸 중 아무 냄새가 없는 칸의 방향으로 잡는다.
2) 그런 칸이 없으면 자신의 냄새가 있는 칸의 방향으로 잡는다.
3) 이때 가능한 칸이 여러 개일 수 있는데, 그 경우에는 특정한 우선순위를 따른다.
우선순위는 상어마다 다를 수 있고, 같은 상어라도 현재 상어가 보고 있는 방향에 따라 또 다를 수 있다.
상어가 맨 처음에 보고 있는 방향은 입력으로 주어지고, 그 후에는 방금 이동한 방향이 보고 있는 방향이 된다.

모든 상어가 이동한 후 한 칸에 여러 마리의 상어가 남아 있으면, 가장 작은 번호를 가진 상어를 제외하고 모두 격자 밖으로 쫓겨난다.

<입력>
첫 줄에는 N, M, k가 주어진다. (2 ≤ N ≤ 20, 2 ≤ M ≤ N2, 1 ≤ k ≤ 1,000)

그 다음 줄부터 N개의 줄에 걸쳐 격자의 모습이 주어진다. 0은 빈칸이고, 0이 아닌 수 x는 x번 상어가 들어있는 칸을 의미한다.

그 다음 줄에는 각 상어의 방향이 차례대로 주어진다.
1, 2, 3, 4는 각각 위, 아래, 왼쪽, 오른쪽을 의미한다.

그 다음 줄부터 각 상어의 방향 우선순위가 상어 당 4줄씩 차례대로 주어진다. 각 줄은 4개의 수로 이루어져 있다.
하나의 상어를 나타내는 네 줄 중
첫 번째 줄은 해당 상어가 위를 향할 때의 방향 우선순위,
두 번째 줄은 아래를 향할 때의 우선순위,
세 번째 줄은 왼쪽을 향할 때의 우선순위,
네 번째 줄은 오른쪽을 향할 때의 우선순위이다.
각 우선순위에는 1부터 4까지의 자연수가 한 번씩 나타난다.
가장 먼저 나오는 방향이 최우선이다. 예를 들어, 우선순위가 1 3 2 4라면, 방향의 순서는 위, 왼쪽, 아래, 오른쪽이다.

맨 처음에는 각 상어마다 인접한 빈 칸이 존재한다. 따라서 처음부터 이동을 못 하는 경우는 없다.

<출력>
1번 상어만 격자에 남게 되기까지 걸리는 시간을 출력한다. 단, 1,000초가 넘어도 다른 상어가 격자에 남아 있으면 -1을 출력한다.
'''

n,m,k=map(int,input().split())

# 격자의 상태
board=[]
# 현재 상어의 위치 좌표값 저장하는 리스트
shark=[[] for _ in range(m)]

# 1,2,3,4 위, 아래, 왼쪽, 오른쪽
dx=[0,-1,1,0,0]
dy=[0,0,0,-1,1]

for i in range(n):
    board.append(list(map(int,input().split())))
    for j in range(n):
        if board[i][j]!=0:
            shark[board[i][j]-1].extend([i,j])
            board[i][j]=[board[i][j],k]

# 각 상어의 처음 방향
d=list(map(int,input().split()))
for i in range(m):
    shark[i].append(d[i])

# 우선순위를 저장할 배열 상어가 2마리라면, 이런 형태 [ [ [2,1,4,3], [1,2,3,4], [2,3,1,4], [4,3,2,1] ] ,  [ [2,1,4,3], [1,2,3,4], [2,3,1,4], [4,3,2,1] ] ]
dir=[[] for _ in range(m)]
idx=-1
for i in range(4*m):
    if i%4==0:
        idx+=1
    dir[idx].append(list(map(int,input().split())))

ans=0
while True:
    ans+=1
    if ans==1001:
        print(-1)
        break

    # 현재 라운드에 같은 칸에 상어가 들어갔는지 확인하기 위한 리스트
    check=[[0 for _ in range(n)] for _ in range(n)]

    # 각 상어 이동 시작
    for i in range(m):
        # 지금 보고있는 상어가 격자 바깥으로 쫓겨나지 않았다면
        if shark[i]!=0:
            x,y,d,smell_flag=shark[i][0],shark[i][1],shark[i][2],0
            # 우선, 우선순위대로 아무 냄새가 없는 칸부터 찾기
            for j in range(4):
                # 현재 상어의, 바라보는 방향의 우선순위 순서대로 탐색
                ndir=dir[i][d-1][j]
                nx=x+dx[ndir]
                ny=y+dy[ndir]
                # 다음 위치가 이동가능한 위치이면서
                if 0<=nx<n and 0<=ny<n:
                    # 냄새가 안나는 칸이라면
                    if board[nx][ny]==0:
                        smell_flag=1
                        break

            # 이동할 수 있는 칸 중 냄새가 안나는 칸이 없다면, 자기 자신의 냄새가 나는 칸으로 이동
            if smell_flag==0:
                for j in range(4):
                    ndir=dir[i][d-1][j]
                    nx=x+dx[ndir]
                    ny=y+dy[ndir]

                    # 다음 위치가 이동가능한 위치이면서
                    if 0<=nx<n and 0<=ny<n:
                        # 자기 자신 냄새가 나는 칸이라면
                        if board[nx][ny][0]==i+1:
                            break

            # 현재 이동한 칸에 이미 다른 상어가 있다면
            if check[nx][ny]:
                if check[nx][ny]<i+1:
                    shark[i]=0
                else:
                    shark[check[nx][ny]-1]=0
            else:
                check[nx][ny]=i+1
                shark[i]=[nx,ny,ndir]

    # 한 라운드가 다 돌고나면,
    # 1초가 지났으므로 상어가 냄새를 뿌리고 간 칸에서 1초를 빼주고
    # 만약 시간이 지나서 0이 되었다면, 현 위치엔 아무것도 없는 것으로 0으로 초기화
    for i in range(n):
        for j in range(n):
            if board[i][j]:
                board[i][j][1]-=1
                if board[i][j][1]==0:
                    board[i][j]=0

    # 각각의 shark는 새로운 위치로 이동했으므로 현재 위치를 확인해주면서
    # board에 입력
    for i in range(m):
        # 현재 shark가 격자 안에 있는지부터 확인
        if shark[i]:
            x,y=shark[i][0],shark[i][1]
            board[x][y]=[i+1,k]

    # shark의 리스트에서 0의 개수가 m-1개 이면 1번 상어만 남은 것이기 때문에 현재 값을 출력
    if shark.count(0)==m-1:
       print(ans)
       break
